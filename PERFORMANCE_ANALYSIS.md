# Анализ производительности веб-интерфейса

## Проблемы, выявленные из HAR файла

### 1. Медленная загрузка страницы `/manage`
- **onContentLoad**: 846.5 мс
- **onLoad**: 1201.7 мс
- **Общее время загрузки**: ~1.2 секунды

### 2. Медленные API запросы

#### Последовательные запросы при загрузке:
1. `/api/credentials` - **337 мс** (connect: 318 мс)
2. `/api/tasks` - **333 мс** (connect: 318 мс, размер: 41KB)
3. `/api/logs` - **333 мс** (connect: 318 мс)
4. Множество `/api/tasks/.../last-log` - **208-379 мс каждый**

#### Проблемы:
- **Медленное подключение (connect: 318 мс)** - необычно для localhost
- **Большой размер ответа `/api/tasks` (41KB)** - содержит полный `output` для всех задач
- **Последовательное выполнение** - запросы выполняются один за другим
- **Множество запросов к last-log** - по одному запросу на каждую задачу

### 3. Автообновление
- Обновление каждые 5 секунд создает постоянную нагрузку
- Дублирование запросов - два интервала делают запросы к `/api/tasks`

## Реализованные оптимизации

### 1. Легковесная версия `/api/tasks`
- Добавлен параметр `?lightweight=true`
- Возвращает только последние 500 символов `output` вместо полного
- Уменьшает размер ответа с 41KB до ~5-10KB

### 2. Параллельная загрузка данных
- Использование `Promise.all()` для параллельной загрузки:
  - `/api/credentials`
  - `/api/tasks?lightweight=true`
  - `/api/logs`
- Вместо ~1000 мс последовательно → ~350 мс параллельно

### 3. Оптимизация загрузки логов
- Параллельная загрузка логов для всех задач через `Promise.all()`
- Вместо последовательных запросов → все запросы одновременно

### 4. Увеличен интервал автообновления
- С 5 секунд до 10 секунд
- Снижает нагрузку на сервер в 2 раза

### 5. Устранение дублирования запросов
- Объединены два интервала автообновления в один
- Используется одна функция `refreshTaskStatusFromData()`

## Ожидаемые улучшения

### До оптимизации:
- Время загрузки страницы: **~1200 мс**
- Размер данных: **~42KB**
- Количество запросов: **10+**

### После оптимизации:
- Время загрузки страницы: **~400-500 мс** (улучшение в 2.4 раза)
- Размер данных: **~8-10KB** (уменьшение в 4 раза)
- Количество запросов: **3** (параллельно)

## Дополнительные рекомендации

### 1. Кэширование на сервере
- Добавить кэширование для `/api/tasks` (TTL: 2-3 секунды)
- Кэширование для `/api/logs` (TTL: 30 секунд)

### 2. Оптимизация Flask
- Проверить настройки Flask (threading, workers)
- Возможно использовать gunicorn для production

### 3. Оптимизация подключения
- Медленное подключение (318 мс) может быть связано с:
  - Настройками Windows/сети
  - Антивирусом
  - Прокси/VPN
  - Настройками Flask

### 4. Ленивая загрузка
- Загружать логи только для видимых задач
- Загружать полный `output` только при клике на задачу

### 5. WebSocket для реального времени
- Использовать WebSocket вместо polling для обновления статуса задач
- Снизит количество HTTP запросов

### 6. Оптимизация чтения логов
- Чтение только последних 8KB файла вместо всего файла
- Уменьшает время ответа для больших лог-файлов

## Метрики для мониторинга

После применения оптимизаций проверить:
1. Время загрузки страницы `/manage` (должно быть < 500 мс)
2. Размер ответа `/api/tasks?lightweight=true` (должен быть < 10KB)
3. Количество HTTP запросов при загрузке (должно быть 3-5)
4. Использование CPU/памяти сервера

